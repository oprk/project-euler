"""
Singular integer right triangles

Problem 75

It turns out that 12 cm is the smallest length of wire that can be bent to form an integer sided right angle triangle in exactly one way, but there are many more examples.

12 cm: (3,4,5)
24 cm: (6,8,10)
30 cm: (5,12,13)
36 cm: (9,12,15)
40 cm: (8,15,17)
48 cm: (12,16,20)

In contrast, some lengths of wire, like 20 cm, cannot be bent to form an integer sided right angle triangle, and other lengths allow more than one solution to be found; for example, using 120 cm it is possible to form exactly three different integer sided right angle triangles.

120 cm: (30,40,50), (20,48,52), (24,45,51)

Given that L is the length of the wire, for how many values of L ≤ 1,500,000 can exactly one integer sided right angle triangle be formed?
"""

"""
Naive solution, is to write a function that returns True/False for whether a length of wire L has exactly one integer sided right angle triangle.

Another solution is to figure out how to generate all integer sided right angle triangles.
Multiples of (3, 4, 5): (6, 8, 10), (9, 12, 15), ...

http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Pythag/pythag.html#section2.1
2.1 The simplest method of finding all Pythagorean triples

2.4 The m,n formula for generating Pythagorean Triples
Yes - we can generate Pythagorean Triples by supplying two different positive integer values for m and n in this diagram. You can multiply out these terms and check that
( m2 – n2 )2 + (2 m n)2 = ( m2 + n2 )2

Are all the Pythagorean triples generated by m,n?
The bad news is that the answer is "No", but the good news is that all primitive Pythagorean triples are generated by some m,n values in the formula above!

"""


"""
If we have a way of generating all Pythagorean triples, we can make an array/map of length 1.5M to count, for each integer i, how many Pythagorean triples of length i.

After counting the number of Pythagorean triples for each i, we can find how many of them have exactly one Pythagorean triple.

;; Generating Pythagorean triples.

http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Pythag/pythag.html#section2.1

The method is mentioned in Kraitchik's Mathematical Recreations on page 97:
If a2 + b2 = h2 then
a2 = h2 - b2 which factorises:
a2 = (h + b)(h - b)
So find two factors of a2, say P and Q and P>Q. Then
P = h + b, Q = h - b which means that
h = (P + Q)/2, b = (P - Q)/2.

In order that P and Q are whole numbers, P and Q must be both odd or both even and P > Q (or else b is 0 or negative).
Let's try an example with a = 12:
a2 = 144. Possible P and Q are:
 P=144,Q=1 but one is even and one odd (giving a fractional value for b and h)
 P=72, Q=2 and both are even
(P+Q)/2 = h = 37; (P-Q)/2 = b = 35: the triple is a=12, b=35, h=37
 P=48, Q=3 but one is even and one odd (giving a fractional value for b and h)
 P=36, Q=4 and both are even
(P+Q)/2 = h = 20; (P-Q)/2 = b = 16: the triple is a=12, b=16, h=20
 P=24, Q=6 and both are even
(P+Q)/2 = h = 15; (P-Q)/2 = b = 9: the triple is a=12, b=9, h=15
 P=18, Q=8 and both are even
(P+Q)/2 = h = 13; (P-Q)/2 = b = 5: the triple is a=12, b=5, h=13
 P=16, Q=9 but one is even and one odd (giving a fractional value for b and h)


So we start with "a = 12", and find all its factors.

I can write a function that spits out the prime factorizations of "a".

"""

import collections
import time

# In order to generate prime factorizations, we need to have a list of primes.
def primes(max_num):
  if max_num >= 2:
    prime_bitmap = [True for x in range(max_num)]
    prime_bitmap[0] = False
    prime_bitmap[1] = False
    for i in range(max_num):
      if prime_bitmap[i]:
        yield i
        for j in range(i**2, max_num, i):
          prime_bitmap[j] = False

# How long would this take?  Let's time it.
t0 = time.time()
known_primes = list(primes(15000000))
t1 = time.time()
# known_primes[:10]
# [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

# print(len(known_primes))
# 970704

# print('time %f' % (t1 - t0))
# time 2.762531
# This isn't so bad!

# Returns a python Counter of the number of times the prime is used in the prime factorization of n
# https://docs.python.org/3/library/collections.html#collections.Counter
def prime_factors(num):
  factors = []
  for prime in known_primes:
    if num == 1:
      return factors
    while (num % prime) == 0:
      num /= prime
      factors.append(prime)
  return factors

# All factors of a number, from the combinations of the primes.
def all_factors(num):
  # 1 is a factor for all numbers.
  factors = [1]
  p_factors = dict(collections.Counter(prime_factors(num)))
  primes = p_factors.keys()
  for prime in primes:
    count = p_factors.pop(prime, None)
    # p_factors now contains the rest of the prime factors.
    new_factors = []
    for i in range(count + 1):
      mult = prime**i
      for f in factors:
        new_factors.append(mult * f)
    factors = new_factors
  return factors

# all_factors(12)
# [1, 2, 4, 3, 6, 12]

# all_factors(144)
# [1, 2, 4, 8, 16, 3, 6, 12, 24, 48, 9, 18, 36, 72, 144]

def all_factors_squared(num):
  # 1 is a factor for all numbers.
  factors = [1]
  p_factors = dict(collections.Counter(prime_factors(num)))
  primes = p_factors.keys()
  # Double the count of all the prime factors.
  for prime in primes:
    p_factors[prime] *= 2
  for prime in primes:
    count = p_factors.pop(prime, None)
    # p_factors now contains the rest of the prime factors.
    new_factors = []
    for i in range(count + 1):
      mult = prime**i
      for f in factors:
        new_factors.append(mult * f)
    factors = new_factors
  return factors


def pythagorean_triples_for_side(a_side):
  a2 = a_side**2
  # q_candidates = all_factors(a2)
  q_candidates = all_factors_squared(a_side)
  for q in q_candidates:
    p = a2 // q
    if p <= q:
      continue
    # In order that P and Q are whole numbers, P and Q must be both odd or both
    # even and P > Q (or else b is 0 or negative).
    if (p % 2) == (q % 2):
      hypotenuse = (p + q) // 2
      b_side = (p - q) // 2
      yield tuple(sorted((a_side, b_side, hypotenuse)))

# list(pythagorean_triples_for_side(12))
# [(12, 35, 37), (12, 16, 20), (5, 12, 13), (9, 12, 15)]


# Given that L is the length of the wire, for how many values of L ≤ 1,500,000
# can exactly one integer sided right angle triangle be formed?

# The largest side must be under 1.5//2 = 750000.

# max_length = 1500000
def result(max_length):
  t0 = time.time()
  arr = [set() for i in range(max_length + 1)]

  for side in range(1, max_length // 2):
    triples = list(pythagorean_triples_for_side(side))
    for triple in triples:
      length = sum(triple)
      if length <= max_length:
        arr[length].add(triple)

  total = 0
  for length in range(1, max_length + 1):
    if len(arr[length]) == 1:
      total += 1
      # print(length, arr[length])
  t1 = time.time()
  print(total)
  print('time %f' % (t1 - t0))
  return total

# total = result(100000)
# 11013
# time 3.322791

# total = result(200000)
# 21964
# time 8.962480
# Implemented "all_factors_squared" to try to make things faster.
# Didn't make a difference I think.
# 21964
# time 9.002830

# total = result(400000)
# 43664
# time 26.899096

# total = result(1500000)
# 161667
# time 251.640825

"""
Sun May 30 12:31:29 MDT 2021

Congratulations, the answer you gave to problem 75 is correct.

You are the 17741st person to have solved this problem.

This problem has a difficulty rating of 25%. The highest difficulty rating you have solved remains at 25%.


If you are keen to share your insights and/or wish to see how other members have solved the problem, then please visit thread 75 in our private discussion forum.
https://projecteuler.net/thread=75

snq  Sweden   C/C++Thu, 26 Aug 2004, 03:53
If anyone's interested, here's my code. It takes around 50 msecs to come up with the answer.
C/C++

class Problem75
{
  private static int max = 1000000;
  private static byte[] count = new byte[max+1];

  private static void Transform(int x, int y, int z)
  {
    int len = x+y+z;
    if(len>max) return;
    for(int l=len; l<=max; l+=len) count[l]++;
    Transform( x-2*y+2*z,  2*x-y+2*z,  2*x-2*y+3*z);
    Transform( x+2*y+2*z,  2*x+y+2*z,  2*x+2*y+3*z);
    Transform(-x+2*y+2*z, -2*x+y+2*z, -2*x+2*y+3*z);
  }

  public static void Solve()
  {
    Transform(3, 4, 5);

    int total = 0;
    for(int i=0; i<=max; i++)
      if(count[i]==1) total++;
    Console.WriteLine(total);
  }
}

What's this algorithm?
https://mathworld.wolfram.com/PythagoreanTriple.html

"""

# I can totally improve on this runtime.
